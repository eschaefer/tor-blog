<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Tor Project</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A layout example that shows off a blog page with a list of posts.">
    <meta name="robots" content="noindex" />
    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/styles.css">

    <!--[if lte IE 8]>
      <link rel="stylesheet" href="css/blog-old-ie.css">
    <![endif]-->
    <!--[if lt IE 9]>
      <script src="http://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.js"></script>
    <![endif]-->
</head>
<body>

<body>
<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
        <div class="header">
            <a href="/"><img class="tor-logo" src="/assets/images/tor_logo.png" alt="Tor logo" /></a>
            <h1 class="brand-title">The Tor Project Blog</h1>
            <h2 class="brand-tagline">News and events from Tor</h2>

            <nav class="nav">
                <ul class="nav-list">
                    <li class="nav-item">
                        <a class="pure-button" href="/events/">Events</a>
                    </li>
                    <li class="nav-item">
                        <a class="pure-button" href="https://www.torproject.org/overview">About Tor</a>
                    </li>
                    <li class="nav-item">
                        <a class="pure-button" href="https://www.torproject.org/donate/donate">Donate</a>
                    </li>
                </ul>
            </nav>
        </div>
    </div>

    <div class="content pure-u-1 pure-u-md-3-4">
        <div>

            <!-- A wrapper for all the blog posts -->
<div class="posts">

  <h1 class="content-subhead">Recent Posts</h1>
  <div id="home">
    
      <section class="post">
        <header class="post-header">
          <h2 class="post-title"> <a href="/blog/summer-torbutton">Summer of Torbutton</a></h2>
          <p class="post-meta">
              By <a class="post-author" href="#">koryk</a> under
              
                <a class="post-category post-category-js" href="/tag/gsoc torbutton">gsoc torbutton</a>
               |
              16 Sep 2009
          </p>
        </header>
        <div class="post-description">
          <p>This summer I have been working on new feature for the Torbutton Firefox extension with Mike Perry as my mentor. The Tor Project volunteer page describes this project as requiring a high skill and effort level. Initially, I was confident in the effort that I was capable of putting forth, however I was doubtful of my skill level. My knowledge of XUL (an xml based markup language for the Mozilla Framework) and Javascript was a medium at best. Knowing that I was going to have to spend a good amount of time becoming adept with these languages, I took on writing three new features for Torbutton.</p>

<p>The first feature is handling tor:// and tors:// urls. I implemented these protocols to be handled by Torbutton, and will be opened in your Tor connection. If you do not have Tor enabled, you will be prompted to enable it. In addition, I added options in any link’s context menu for copying Tor URLs and opening them in a new window or tab.</p>

<p>The next feature I implemented was a referrer spoofer. The ‘referer’ http header field allows your browser to specify the address of the webpage of the resource which links to it. By checking the referrer, a new page can see where the request came from. Referrers leak information and reduce a user’s anonymity set. My feature intercepts the header and rewrites it. There are options to: leave the referrer blank, make the domain the referrer, make the root folder of the page the referrer, or a custom referrer.</p>

<p>The last feature I implemented was the Cookie Protecter. When enabled, the Cookie Protector allows a user to choose which cookies are saved/deleted on Tor toggle. The Cookie Protector is a dialog that shows all of your current cookies. A user can then delete cookies and choose ones to be protected upon toggle. The user can also specify whether new cookies are automatically protected or not. When Torbutton is toggled, the protected cookies get jarred up and saved for when the user toggles Torbutton again.</p>

<p>These features are almost ready to be released. There will be a pre-release version that will be out soon, I will notify or-talk when this is ready – so that it can be tested before release. In particular, I am looking for possible security vulnerabilities in my features. The tor/tors protocol is currently a source of vulnerability, because it can be called from many different places in the browser, and could be used to correlate a user’s Tor identity with his/her non-Tor identity. Therefore I want to make sure that it can only be called from a few parts on the page.</p>

<p>I plan on making sure that my features are robust and secure before releasing them, and expect that to be done by the next release of Torbutton. In addition, I plan on continuing to contribute to the Tor Project. I enjoyed my Summer of Code, and now I am looking forward to contributing to Tor.</p>

        </div>
      </section>
    
      <section class="post">
        <header class="post-header">
          <h2 class="post-title"> <a href="/blog/tor-browser-bundle-129-released">Tor Browser Bundle 1.2.9 Released</a></h2>
          <p class="post-meta">
              By <a class="post-author" href="#">phobos</a> under
              
                <a class="post-category post-category-js" href="/tag/firefox update">firefox update</a>
              
                <a class="post-category post-category-js" href="/tag/pidgin update">pidgin update</a>
              
                <a class="post-category post-category-js" href="/tag/security fixes">security fixes</a>
              
                <a class="post-category post-category-js" href="/tag/tor browser bundle">tor browser bundle</a>
              
                <a class="post-category post-category-js" href="/tag/vidalia release">vidalia release</a>
               |
              12 Sep 2009
          </p>
        </header>
        <div class="post-description">
          <p>Tor Browser Bundle 1.2.9 is released today. It updates Firefox and Pidgin Instant Messaging client to address the security issues in the older versions, and includes the latest and greatest Vidalia.</p>

<p>TBB can be downloaded from <a href="https://www.torproject.org/torbrowser" title="https://www.torproject.org/torbrowser">https://www.torproject.org/torbrowser</a>.</p>

<p>The details of the changes are:</p>

<ul>
<li>update Vidalia to 0.2.4</li>
<li>update Qt to 4.5.2</li>
<li>update Pidgin to 2.6.2</li>
<li>update Firefox to 3.0.14</li>
</ul>

        </div>
      </section>
    
      <section class="post">
        <header class="post-header">
          <h2 class="post-title"> <a href="/blog/polipo-portability-enhancements-summary">Polipo Portability Enhancements Summary</a></h2>
          <p class="post-meta">
              By <a class="post-author" href="#">chrisd</a> under
              
                <a class="post-category post-category-js" href="/tag/gsoc 2009">gsoc 2009</a>
              
                <a class="post-category post-category-js" href="/tag/libevent">libevent</a>
              
                <a class="post-category post-category-js" href="/tag/polipo">polipo</a>
               |
              12 Sep 2009
          </p>
        </header>
        <div class="post-description">
          <p>Over the summer for GSoC 2009, I worked on Polipo, Tor&#39;s favored Web proxy for bridging the gap between HTTP and SOCKS protocols. The proxy also provides an efficient memory cache to help speed up browsing. I had an opportunity to learn about Polipo and Libevent, and I had a chance to attend <a href="http://petsymposium.org/2009/">PETS</a>, a privacy conference, and meet some of the Tor folks in person. <a href="http://www.pps.jussieu.fr/%7Ejch/software/polipo/">Polipo</a> is authored by Juliusz Chroboczek. <a href="http://www.monkey.org/%7Eprovos/libevent/">Libevent</a> is developed by Nick Mathewson and Niels Provos. Nick Mathewson also happens to work for the Tor Project and was my GSoC mentor over the summer.</p>

<p>My work included integrating support for Libevent, a library for managing I/O events portably. The main advantage of using Libevent over Polipo&#39;s built-in event loop is Libevent&#39;s support of platform-specific APIs for monitoring large numbers of connections for I/O events. Polipo, when compiled to use Libevent, should be quicker when juggling many open connections. Informal benchmarking seemed to back this up, although more thorough profiling is still TODO. Modern versions of Libevent also contain an asynchronous DNS resolver, which I tied into Polipo, as well. Polipo&#39;s original event system and asynchronous DNS resolver are still available in case Libevent is unavailable on a user&#39;s system.</p>

<p>I also did some work to get Polipo to run better on Windows. I got a start fixing the disk cache and path name handling, Windows socket errors should now be printed correctly, and SIGINT and SIGBREAK signals are handled to cleanly quit when the user hits Ctrl-C or closes the DOS box. Also, Libevent&#39;s DNS resolver supports fetching name servers from the Windows registry, so Polipo no longer should block when performing lookups when it is compiled with Libevent support. More work remains to refine Windows support, but I hope this is a good start.</p>

<p>The main thing that I left undone during GSoC is the controller GUI for launching and managing Polipo on Windows and providing status information to the user. The exact design of the GUI is still up for discussion, but it shouldn&#39;t take too much time to develop once something is settled on. I&#39;m currently working on modifications to Polipo&#39;s configurator to support the controller, and this is going pretty smoothly.</p>

<p>Looking farther ahead, it would be good to consider a few ways to improve Polipo&#39;s performance. Roger mentioned to me during PETS that retrieving web pages might be made more efficient by packing client requests into Tor&#39;s RELAY BEGIN cells, so that the requests can be sent by the exit node immediately after connection to the requested server without the additional latency that currently exists while the client waits for notice of a successful connection. This would require changes to Polipo and Tor to implement, and there may be design issues worth considering, such as the limited payload space available in cells. Another thing that could potentially increase performance is adding support for Libevent&#39;s buffer events, which make use of more efficient I/O routines on Windows. This would be pretty difficult to do, yet worth considering.</p>

<p>Working on this project was a fun and informative experience, and I hope to stay a member of the Tor community. I&#39;ve had some experience working on open source projects before, but it&#39;s unique to find developers as dedicated as those working on Tor. In fact, Tor is a full-time job for several of the developers, and I think seeing a high level of development activity helps to keep volunteers around.</p>

        </div>
      </section>
    
      <section class="post">
        <header class="post-header">
          <h2 class="post-title"> <a href="/blog/bittorrent-support-thandy">BitTorrent support for Thandy</a></h2>
          <p class="post-meta">
              By <a class="post-author" href="#">Sebastian</a> under
              
                <a class="post-category post-category-js" href="/tag/BitTorrent">BitTorrent</a>
              
                <a class="post-category post-category-js" href="/tag/google">google</a>
              
                <a class="post-category post-category-js" href="/tag/Google Summer of Code">Google Summer of Code</a>
              
                <a class="post-category post-category-js" href="/tag/gsoc">gsoc</a>
              
                <a class="post-category post-category-js" href="/tag/thandy">thandy</a>
               |
              10 Sep 2009
          </p>
        </header>
        <div class="post-description">
          <p>As a returning <a href="http://socghop.appspot.com/org/home/google/gsoc2009/eff">Google Summer of Code</a> student for the second year in a row, I was thrilled to hear that I had been accepted again.</p>

<p>My task was to add <a href="http://www.bittorrent.com/">BitTorrent</a> support to <a href="https://git.torproject.org/checkout/thandy/master/">Thandy</a>, the secure automated updater <a href="http://google-opensource.blogspot.com/2009/03/thandy-secure-update-for-tor.html">developed</a> by the Tor project, along with setting up and testing the necessary infrastructure. The goal is to better mitigate load spikes following the release of new software versions and allowing volunteers to easily help users to fetch Tor.</p>

<p>Of course, working wasn&#39;t without its own challenges. My mentor and I live in different parts of the world, and real-time communication was often difficult to achieve due to timezone differences. Another big challenge was staying motivated during the first month, where university demanded a lot of attention. The situation improved substantially after the mid-term evaluation, when school-related work became less time consuming and I could focus on SoC entirely. During the whole time, I communicated with some of Tor&#39;s other SoC students, helping, encouraging and sharing some great laughs with each other. I feel that the community aspect of GSoC worked out much better this year.</p>

<p>During the summer, it became apparent that following through with the original plan of using the <a href="http://www.rasterbar.com/products/libtorrent/index.html">C++ libtorrent implementation by rasterbar</a> would be difficult, due to various platform-independence issues and a huge resulting binary. Especially the last point made it clear that we wouldn&#39;t be able to use that for our netinstaller, one of the most important reasons to develop Thandy. Eventually, I settled on the original BitTorrent implementation, patched by Debian to work around some issues with newer versions of Python.</p>

<p>It was great to see that this year, all my code has been merged into the Thandy source. I think my experience from last year saved me from making the same mistakes again, by focusing on small parts that work instead of re-designing major aspects of the software.</p>

<p>Overall, I&#39;m very happy with how my Summer of Code turned out to be, and I hope to participate again (either as student or even mentor)!</p>

        </div>
      </section>
    
      <section class="post">
        <header class="post-header">
          <h2 class="post-title"> <a href="/blog/bridge-distribution-strategies">KAIST freshmen working on bridge distribution strategies</a></h2>
          <p class="post-meta">
              By <a class="post-author" href="#">arma</a> under
               |
              09 Sep 2009
          </p>
        </header>
        <div class="post-description">
          <p>Thanks to a friend who&#39;s a professor at <a href="http://www.kaist.edu/edu.html">KAIST</a> in Korea, several teams of students there are working for their &quot;freshman design class&quot; on designing new bridge (aka bridge relay) distribution strategies. Here&#39;s some early brainstorming on what the actual problems are and what needs doing.</p>

<p>Background: Tor uses directory servers to give out information about what relays are in the network. But blocking connections between users and the main Tor network is actually not that hard — after all, there&#39;s a public list of relays, which needs to stay public so clients can know where to connect. That&#39;s where <a href="https://www.torproject.org/docs/bridges.html.en">bridge relays</a> come in. Now that we&#39;ve deployed bridge relays, we changed the arms race from &quot;how do we prevent the adversary from learning about 2000 IP address that we&#39;re openly publishing?&quot; (which is an impossible problem) to &quot;how do we take these several thousand secret IP addresses and give them out one at a time to the good guys, without letting the bad guys learn all of them?&quot; Hopefully that&#39;s a more manageable arms race. You can read more background in the <a href="https://svn.torproject.org/svn/projects/design-paper/blocking.html">blocking-resistance design doc</a> and <a href="http://freehaven.net/%7Earma/23C3-1444-en-tor_and_china.m4v">video</a>.</p>

<p>Here&#39;s the problem in a nutshell: what are some creative ways to distribute the IP addresses for bridge relays, such that ordinary users can generally learn a few bridge addresses, but an attacker can&#39;t learn all of them?</p>

<p>The key point is that we need diversity of distribution strategies. It&#39;s hard to predict the interests and capabilities of the adversary, so it will be hard to predict which strategies are going to be successful.</p>

<p>How do bridges work behind the scenes? Bridge relays anonymously upload their <a href="https://www.torproject.org/docs/faq#KeyManagement">server descriptors</a> to the bridge authority, which aggregates the list and checks which bridges are reachable and working. We&#39;ve written a set of tools called <a href="https://gitweb.torproject.org/bridgedb.git/tree">bridgedb</a> that looks at this list and gives out addresses to users according to various strategies. Each bridge address is only available via one of the strategies, so if one strategy turns out to be weak, the attacker only gets to learn the bridges associated with that strategy.</p>

<p>So far we&#39;ve deployed three simple strategies: IP-based, email autoresponder, and manual. For the IP-based strategy, we look at which IP address you&#39;re coming from and list a few bridges, but we always answer a given IP address with the same list. That way an attacker needs to have a wide variety of IP addresses before he can learn many of the bridges allocated to this strategy. For the email autoresponder, we answer a given email address with a few bridges, but we answer the same way if that email address asks again. And for the manual strategy, we keep some bridge addresses in reserve, a) in case the other two strategies get broken at the same time, and b) to be able to give them out to people who ask on IRC, IM, etc.</p>

<p>Of course, it gets much more complex when we consider all the practical issues that come up. For example, for the IP-based strategy, we need to count nearby addresses (e.g. the whole <a href="http://en.wikipedia.org/wiki/Netmask">/24 netblock</a>) as the same address, or an attacker with a single class C could be lots of different addresses. We also need to treat open proxies — and Tor exit relays! — separately, or it&#39;s too easy to search for <a href="http://www.google.com/search?q=open+proxies">open proxies</a> and beat it. Tor provides an easy-to-use <a href="https://check.torproject.org/cgi-bin/TorBulkExitList.py">list of exit addresses</a>, but how do we easily collect an up-to-date list of open proxy addresses?</p>

<p>And for the email autoresponder, how do we prevent an attacker who controls a given domain from just creating thousands of email addresses at that domain, and learning lots of bridges? Our current answer is to only answer requests from a few domains — in particular, Gmail — that we know have reasonable ways to slow down creation of lots of accounts. In this way we leverage Gmail&#39;s &quot;is a human&quot; checks without having to design our own. Gmail also provides another feature: it signs all its outgoing mail using <a href="http://en.wikipedia.org/wiki/DomainKeys_Identified_Mail">dkim</a>. If it didn&#39;t, an attacker could forge mail from a variety of Gmail addresses and make it look like we&#39;re spamming them. After a while, Gmail would mark us as a spam source, and suddenly none of our mails would get through anymore.</p>

<p>How do we handle churn? After all, if we are truly answering the same address with the same set of bridges, then if those bridges go away, we&#39;ll be giving out useless addresses. Our current answer is based on <a href="http://en.wikipedia.org/wiki/Consistent_hashing">consistent hashing</a>. We hash each bridge&#39;s identity key, and then when a request comes in, we hash that request&#39;s address. Whichever hash(bridge key) is nearest to that hash(address) is the one we give out, along with the two bridges after that for robustness. Now we&#39;re always giving out bridges from the same location in the hash table, even if one of those bridges disappears for a while (or a new one shows up).</p>

<p>We could imagine a lot more strategies. For example, the user SMS&#39;s us from a given phone number, and we send a few bridge addresses back. Or we wrap the bridge addresses using <a href="http://www.google.com/search?q=time-release+crypto">time-release crypto</a>, such that it takes the user (or the attacker) a few hours of CPU-time to decrypt it. Or we get all the users to subscribe to a mailing list, and we send out a new bridge address every 6 hours, in hopes that the users can use them a while before the attacker gets around to blocking them. Or heck, another strategy would be just collecting $10 from the user for each request for bridge addresses.</p>

<p>Another option is a social networking approach: rather than relying on technical tricks, rely on trust between humans to limit the risk that bridge addresses will fall into the wrong hands, and maybe construct a reputation system to identify participants whose bridge addresses get blocked more often than they &quot;should&quot;. This idea gets messy quickly: see <a href="https://svn.torproject.org/svn/projects/design-paper/blocking.html#tth_sEc7.4">&quot;strategy six&quot;</a> in the blocking-resistance design doc for more thoughts.</p>

<p>There are four components to tackling this general design question.</p>

<p>1) Identify some resources such that it&#39;s straightforward to get a few of them, but harder to get many of them. The ones I listed above are just a few examples, and I&#39;m sure there are dozens more out there.</p>

<p>2) Speculate about the capabilities of various attackers (ISPs, countries, intelligence agencies, companies, etc), and analyze how hard it would actually be for them to collect lots of the resource. The ideal resource here would be something that&#39;s asymmetric, such that the right individuals can get it cheaply but the wrong parties will find it expensive. For example, the strategies based on IP address, email account, or even phone number are brittle: they would not stand up well to an attacker who has access to lots of different IP networks, can solve thousands of captchas, or owns a phone company. The social network based approach is an example of a resource that&#39;s more asymmetric: infiltrating a human-based network takes more resources than solving a bunch of captchas. Figure out which attackers your strategy is robust against, and which attackers it isn&#39;t.</p>

<p>3) Figure out how you&#39;d actually build it in practice, and how you could make it more robust against attack. Where do we get a list of open proxies for the IP address strategy, and how effective would that actually be at slowing down various attackers? How do you receive SMS&#39;s on the Internet, and how do you send them in a sustainable (e.g. free) way? What is the true cost of getting a new phone number? (Gmail sometimes demands a new phone number for creating an account — this approach created an unexpected secondary market, where spammers would buy a new SIM card, use it just for its phone number, then resell it for almost full price since all the minutes were intact.) How hard is it in practice (measured in time, cash, skills, etc) to get 500 Gmail accounts? How do you pick the &quot;seeds&quot; of your social network, and are there unexpected security problems that come up, e.g. keeping sensitive information about users on a central site that the adversary could attack? These questions are only a few examples, and you&#39;ll have to extrapolate from them to figure out good questions to ask for your own designs.</p>

<p>4) The best way to figure out if you&#39;ve thought about all the issues is to actually try to build it. You could build it as a module in the bridgedb tools, or as a separate standalone program. Try to have your friends (or other design teams) attack it, and see if they come up with new approaches or vulnerabilities that you hadn&#39;t considered.</p>

<p>While you&#39;re at it, there are a variety of other design questions that come up around bridges, and understanding them may help you come up with good approaches.</p>

<p>1) We only have about 500 bridge addresses right now total. Does your distribution strategy work well when it&#39;s trying to protect only a few hundred bridge addresses, or does it only start to be effective when there are tens of thousands?</p>

<p>2) Some of these strategies, like the SMS approach, might be able to be monitored by the attacker. Thus a) he can passively enumerate bridge addresses just by monitoring his own users, and b) he can passively enumerate people who ask for bridge addresses. First of all that vulnerability makes the strategy less robust (it&#39;s easier than we thought for that class of attacker to gather addresses). But second, it may put the users at higher risk. Strategies like the Gmail auto-responder might be safer, since the users have SSL link encryption when sending and receiving mail. That is, assuming they trust Google.</p>

<p>3) It&#39;s a shame that we need to use a centralized bridge authority here. That means an attacker who can break into the bridge authority can learn all of the bridge addresses at once. Further, the bridge authority needs to learn which bridges are reachable (to know which ones to give out), which provides another avenue for an attacker. Are there ways to distribute bridge addresses over more than one bridge authority, in a way that can handle churn and still preserves our rate-limited release properties?</p>

<p>4) How do we test whether bridges are reachable from inside some of these countries? The bridge authority can either test directly (which has problems), or test via Tor (which has different problems). See sections <a href="https://svn.torproject.org/svn/projects/design-paper/blocking.html#tth_sEc7.6">7.6</a> and <a href="https://svn.torproject.org/svn/projects/design-paper/blocking.html#subsec:geoip">7.7</a> of the blocking-resistance document for more discussion.</p>

<p>Overall, a lot of the challenge here comes from not having a good handle on how powerful the attackers might be. In the cryptography world, the standard approach is to assume an extremely powerful attacker, and design a system that can protect against even that. But here, it would seem that convenience and usability are at odds with this traditional approach to strong security — not to mention that we don&#39;t even know how to provide strong (crypto-grade) security in this context.</p>

<p>Last, it&#39;s worth noting that so far no countries have blocked the public Tor network. Tor played a <a href="https://blog.torproject.org/blog/measuring-tor-and-iran-part-two">big role in Iran&#39;s organizations and demonstrations in June</a>, and it has even more users in China, Russia, and other repressive countries. So the arms race has already begun, and none of the adversaries have proved to be powerful enough and/or concerned enough to take a step. Building a broad range of strategies — from convenient but breakable ones to very secure ones — will be the best preparation for however the arms race plays out.</p>

        </div>
      </section>
    

     <!-- Pagination links -->
    <div class="pagination">
      
        <a href="/blog/page110" class="previous">Previous</a>
      
      <span class="page_number ">Page: 111 of 137</span>
      
        <a href="/blog/page112" class="next">Next</a>
      
    </div>
  </div>

</div>


            <div class="footer">
                <div class="pure-menu pure-menu-horizontal pure-menu-open">
                    <ul>
                        <li><a href="http://purecss.io/">About</a></li>
                        <li><a href="http://twitter.com/yuilibrary/">Twitter</a></li>
                        <li><a href="http://github.com/yahoo/pure/">GitHub</a></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>
</body>
</html>
