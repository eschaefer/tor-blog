<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Research problem: better guard rotation parameters</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A layout example that shows off a blog page with a list of posts.">
    <meta name="robots" content="noindex" />
    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/styles.css">

    <!--[if lte IE 8]>
      <link rel="stylesheet" href="css/blog-old-ie.css">
    <![endif]-->
    <!--[if lt IE 9]>
      <script src="http://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.js"></script>
    <![endif]-->
</head>
<body>

<body>
<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
        <div class="header">
            <a href="/"><img class="tor-logo" src="/assets/images/tor_logo.png" alt="Tor logo" /></a>
            <h1 class="brand-title">The Tor Project Blog</h1>
            <h2 class="brand-tagline">News and events from Tor</h2>

            <nav class="nav">
                <ul class="nav-list">
                    <li class="nav-item">
                        <a class="pure-button" href="/events/">Events</a>
                    </li>
                    <li class="nav-item">
                        <a class="pure-button" href="https://www.torproject.org/overview">About Tor</a>
                    </li>
                    <li class="nav-item">
                        <a class="pure-button" href="https://www.torproject.org/donate/donate">Donate</a>
                    </li>
                </ul>
            </nav>
        </div>
    </div>

    <div class="content pure-u-1 pure-u-md-3-4">
        <div>

            <!-- A wrapper for all the blog posts -->
<div class="posts">

  <div id="home">
      <section class="post">
        <header class="post-header">
          <h2 class="post-title"> <a href="">Research problem: better guard rotation parameters</a></h2>
          <p class="post-meta">
              By <a class="post-author" href="#">arma</a> under
              
                <a class="post-category post-category-js" href="#">anonymity</a>
              
                <a class="post-category post-category-js" href="#">anonymity features</a>
              
                <a class="post-category post-category-js" href="#">attackers</a>
              
                <a class="post-category post-category-js" href="#">entry guards</a>
              
                <a class="post-category post-category-js" href="#">guard relays</a>
              
                <a class="post-category post-category-js" href="#">performance</a>
              
                <a class="post-category post-category-js" href="#">protecting users</a>
              
                <a class="post-category post-category-js" href="#">research</a>
               |
              20 Aug 2011
          </p>
        </header>
        <div class="post-description">
          <p>Tor&#39;s <a href="https://www.torproject.org/docs/faq#EntryGuards">entry guard design</a> protects users in a variety of ways.</p>

<p>First, they protect against the &quot; <a href="http://freehaven.net/anonbib/#Wright:2004">predecessor attack</a>&quot;: if you choose new relays for each circuit, eventually an attacker who runs a few relays will be your first and last hop. With entry guards, the risk of end-to-end correlation for any given circuit is the same, but the cumulative risk for all your circuits over time is capped.</p>

<p>Second, they help to protect against the &quot; <a href="http://freehaven.net/anonbib/#ccs07-doa">denial of service as denial of anonymity</a>&quot; attack, where an attacker who runs quite a few relays fails any circuit that he&#39;s a part of and that he can&#39;t win against, forcing Alice (the user) to generate more circuits and thus increasing the overall chance that the attacker wins. Entry guards greatly reduce the risk, since Alice will never choose outside of a few nodes for her first hop.</p>

<p>Third, entry guards raise the startup cost to an adversary who runs relays in order to trace users. Without entry guards, the attacker can sign up some relays and immediately start having chances to observe Alice&#39;s circuits. With them, new adversarial relays won&#39;t have the Guard flag so won&#39;t be chosen as the first hop of any circuit; and even once they earn the Guard flag, users who have already chosen guards won&#39;t switch away from their current guards for quite a while.</p>

<p>But how long exactly? The first research question here examines vulnerability due to natural churn of entry guards. Consider an adversary who runs one entry guard with advertised capacity C. Alice maintains an ordered list of guards (chosen at random, weighted by advertised speed, from the whole list of possible guards). For each circuit, she chooses her first hop (uniformly at random) from the first G guards from her list that are currently running (appending a new guard to the list as needed, but going back to earlier guards if they reappear). How long until Alice adds the adversary&#39;s node to her guard list? You can use the uptime data from the <a href="https://metrics.torproject.org/data.html">directory archives</a>, either to build a model for guard churn or just to use the churn data directly. Assuming G=3, how do the results vary by C? What&#39;s the variance?</p>

<p>Research question two: consider intentional churn due to load balancing too. Alice actually discards each guard between 30 and 60 days (uniformly chosen) after she first picks it. This intentional turnover prevents long-running guards from accumulating more and more users and getting overloaded. Another way of looking at it is that it shifts load to new guards so we can make better use of them. How much does this additional churn factor impact your answer from step one above? Or asked a different way, what fraction of Alice&#39;s vulnerability to the adversary&#39;s entry guard comes from natural churn, and what fraction from the proactive expiration? How does the answer change for different expiry intervals (e.g. between 10 and 30 days, or between 60 and 90)?</p>

<p>Research question three: how do these answers change as we vary G? Right now we choose from among the first three guards, to reduce the variance of expected user performance -- if we always picked the first guard on the list, and some users picked a low-capacity or highly-congested relay, none of that user&#39;s circuits would perform well. That said, if choosing G=1 is a huge win for security, we should work on other ways to reduce variance.</p>

<p>Research question four: how would these answers change if we make the cutoffs for getting the Guard flag more liberal, and/or change how we choose what nodes become guards? After all, Tor&#39;s anonymity is based on the <a href="https://blog.torproject.org/blog/research-problem-measuring-safety-tor-network">diversity of entry and exit points</a>, and while it may be tough to get around exit relay scarcity, my theory is that our artificial entry point scarcity (because our requirements are overly strict) is needlessly hurting the anonymity Tor can offer.</p>

<p>Our current algorithm for guard selection has three requirements:
1) The relay needs to have first appeared longer ago than 12.5% of the relays, or 8 days ago, whichever is shorter.
2) The relay needs to advertise at least the median bandwidth in the network, or 250KB/s, whichever is smaller.
3) The relay needs to have at least the median weighted-fractional-uptime of relays in the network, or 98% WFU, whichever is smaller. (For WFU, the clock starts ticking when we first hear about the relay; we track the percentage of that time the relay has been up, discounting values by 95% every 12 hours.)</p>

<p>Today&#39;s guard cutoffs in practice are &quot;was first sighted at least 8 days ago, advertises 100KB/s of bandwidth, and has 98% WFU.&quot;</p>

<p>Consider two relays, A and B. Relay A first appeared 30 days ago, disappeared for a week, and has been consistently up since then. It has a WFU (after decay, give or take a fencepost) of 786460 seconds / 824195 = 95.4%, so it&#39;s not a guard. Relay B appeared two weeks ago and has been up since then. Its WFU is 658517 / 658517 = 100%, so it gets the Guard flag -- even though it has less uptime, and even less weighted uptime. Based on the answers to the first three research questions, which relay would serve Alice best as a guard?</p>

<p>The big-picture tradeoff to explore is: what algorithm should we use to assign Guard flags such that a) we assign the flag to as many relays as possible, yet b) we minimize the chance that Alice will use the adversary&#39;s node as a guard?</p>

        </div>
      </section>
  </div>

</div>

<div class="comments"></div>

<script type="text/javascript" class="juvia">
(function() {
    var options = {
        container    : '.comments',
        site_key     : 'im3x57usjcg72fkm6lyqzwzt7vaoi4g',
        topic_key    : '/blog/research-problem-better-guard-rotation-parameters',
        topic_url    : location.href,
        topic_title  : document.title || location.href,
        include_base : !window.Juvia,
        include_css  : !window.Juvia,
        comment_order: 'latest-first'
    };

    function makeQueryString(options) {
        var key, params = [];
        for (key in options) {
            params.push(
                encodeURIComponent(key) +
                '=' +
                encodeURIComponent(options[key]));
        }
        return params.join('&');
    }

    function makeApiUrl(options) {
        // Makes sure that each call generates a unique URL, otherwise
        // the browser may not actually perform the request.
        if (!('_juviaRequestCounter' in window)) {
            window._juviaRequestCounter = 0;
        }

        var result =
            'http://torblog-juvia-4525.herokuapp.com/api/show_topic.js' +
            '?_c=' + window._juviaRequestCounter +
            '&' + makeQueryString(options);
        window._juviaRequestCounter++;
        return result;
    }

    var s       = document.createElement('script');
    s.async     = true;
    s.type      = 'text/javascript';
    s.className = 'juvia';
    s.src       = makeApiUrl(options);
    (document.getElementsByTagName('head')[0] ||
     document.getElementsByTagName('body')[0]).appendChild(s);
})();
</script>


            <div class="footer">
                <div class="pure-menu pure-menu-horizontal pure-menu-open">
                    <ul>
                        <li><a href="http://purecss.io/">About</a></li>
                        <li><a href="http://twitter.com/yuilibrary/">Twitter</a></li>
                        <li><a href="http://github.com/yahoo/pure/">GitHub</a></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>
</body>
</html>
